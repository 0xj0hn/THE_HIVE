# Assembly \( NASM \)

this section of the book is about the basics of assembly programming for Intel x86/64 architecture with NASM assembler. this is by no means a full assembly programming tutorial  and i only talk about the basics of coding in ASM just to give the reader an idea about how the computer works in the lowest level \(actually the lowest level is the electrical circuits but you get the idea\). being familiar with how the CPU and RAM work and how operating systems handle the program execution flow is a most for any reverse engineer, exploit developer and obviously, any low-level system programmer such as  malware developer.

{% hint style="info" %}
if your final goal is to become a  reverse engineer/malware analyst or a vulnerability researcher/exploit developer, then you really don't need to know how to write ASM code, you just have to know how to read disassembly. 

the difference between assembly and disassembly is that the first one is the actual code written in one of assemblers such as nasm, fasm, masm or gas but the second one is the result of reversing the assembly process and converting an executable file from the machine instruction generated by the compiler back to the highest level possible which is the assembly language. 

generally when reading disassembly you usually face more surprises because you are dealing with what the compiler generated with a lot of code optimizations that makes it much harder to read and understand. for example IDA is a disassembler that takes a compiled binary executable and shows you the disassembly output.
{% endhint %}

#### as you might have guessed learning assembly is harder than other languages but its not impossible. the only difference is that you have to take care of more things when working with registers and memory. the best way to understand assembly and be able to read disassembly is to write code in a higher level language like C or C++  \( use debugging options when compiling it like '-g' for gcc \) then disassemble it and try to understand the execution flow. you can also have your friend write some C code and compile it then you can disassemble it and try to write the same program in C from the disassembled app.















